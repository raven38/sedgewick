## 再帰呼び出し
---

再帰(*recursion*)は、数学や計算機科学における基礎概念。
簡単な漸化式と再帰プログラムの関係を見る。基本的な問題を解くための分割統治型の再帰プログラムを例示する。最後に再帰プログラムから再帰呼び出しを取り除く方法。

アルゴリズム設計者は再帰的な表現を好む。

#### 漸化式(*recurrence relation*)
---

階乗関数

    N! = N·(N-1)!  if N >= 1
    0! = 1
    
これは![次の再帰プログラム](factorial.c)に直接的に対応する。

フィボナッチ数を定義する漸化式も有名である。


> F<sub>N</sub> = F<sub>N-1</sub> + F<sub>N-2</sub>   if N >= 2
> 
> F<sub>0</sub> = F<sub>1</sub> = 1

![フィボナッチ数](fibonacci.c)

これは効率が悪い。![線形時間で計算するにはこうする](fibonacci2.c)。

配列を使って以前の計算結果を覚えておくのは、漸化式の計算に使う典型的な技法の一つである。これで、けっこう複雑な漸化式を一様な形で能率よく計算できる。漸化式は再帰プログラムの性能解析をするときによく現れる。

#### 分割統治(*divide-and_comquer*)
---

再帰プログラムには、その中で２回再帰呼び出しをしているものが多い。この２回の再帰呼び出しは入力を半分に割って各々に適用する。また大抵の場合、フィボナッチ数のプログラムのように再計算が極度に頻出することはない。


![物差しに目盛りを書き込む](rule.c)。

![非再帰的な](rule_not_rec.c)。

この考え方は、まず自明の部分問題を解き、次にこれらをまとめて少し大きい問題を解くということを繰り返していき、最後の問題全体を解くというアルゴリズム設計の一般的な方法に対応する。この方法は結合統治(*combine-and-conquer*)と呼ばれる。

ボトムアップとトップダウン

![星](star.c)の酔うな再帰的に定義される幾何模様は、フラクタルと呼ばれる事がある。もっとこった描画の基本操作や、もっと複雑な再帰呼び出し(特に複素平面上で再帰的に定義される関数)を使えば、驚くべき多様さと複雑さをもったパターンを生み出せる。

#### 木の再帰的走査
---


木の節点を走査するのは再帰が簡単だって。

![はい、中央順](traverse.c)。

木の再帰的走査はスタックによる実現よりも自然。先行順も中央順も後行順も再帰的に定義されるから。

![二つ目、拡張しただけ](traverse2.c)。

#### 再帰呼び出しの除去
---

再帰版と非再帰版との関係。

![めんどいので一つのファイルで](traverse3.c)。

先行順、これは末尾再帰の除去(*end-recursion removal*)としてよく知られる技法。コンパイラでよく実現されている。

![一気にコードが増えた](not_rec.c)。

#### まとめ
---

再帰は計算の本質を調べる基礎理論の中心的概念。
