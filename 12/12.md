## マージソート
---

9章でファイルの中で*k*番目に小さい要素を見つける選択法を学んだ。選択はファイルを２つに分割して、小さい方の*k*個の要素と大きい方の*N-k*個のように分けることにほぼ等しい。選択と相補的な併合(*merging*)について。

マージソートの考え方はクイックソートに相補的。

*N*個の要素のファイルに対して、最悪の場合でも*N log N*に比例する時間で整列できる。ただ*N*に比例する作業領域が必要になる。

####併合
---

データ処理の仕事では、大きいファイルに新しい項目が付け加えられることが大木。併合は、多くの類似の応用に使えるので、勉強する意義が大きいまた、併合に基づく整列法も調べる。

2ウェイ併合(*two-way merge*)のプログラムを考える。まず最初に、整数を要素とする２つの整列した配列aとbが与えられ、それを併合してcをつくる。aとbから小さい要素を選んでcに移すというもの。

    i = 1; j = 1;
    a[M+1] = INT_MAX; b[N+1] = INT_MAX;
    for(k = 1; k <= M + N; k++)
        c[k] = (a[i]<b[j]) ? a[i++] : b[j++];
        
高々*M+N*回の比較が実行される。

リストと併合は相性がよい。
![リンクによるリストの併合](merge_linked_list.c)

#### マージソート
---

併合手続きに基づいて再帰的な整列法を作る。
![マージソート](mergesort.c)

#### リスト マージソート
---

入力としてリスト表現されたファイルへのポインタを受取、答として、整列したリストへのポインタを返す。

![マージソート](mergesort_linked_list.c)。


#### ボトムアップ型マージソート
---

![not red](mergesort_not_rec.c)。

#### マージソートの性能
---

**性質12.1**　マージソートは*N*個の要素のどんなファイルでも約*N lg N*回の比較で整列する。

**性質12.2** マージソートでは*N*に比例する作業領域を使う。

**性質12.3** マージソートは安定である。

**性質12.4** マージソートの性能は入力の最初の並びに左右されない。


#### プラグラムの最適化
---

aからbへ併合し、一方でbからaへ併合する。

#### 再帰呼び出し
---

クイックソートは統治して分割する。マージソートは分割して統治する