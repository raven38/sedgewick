##順位キュー
---

応用では完全な整列をする必要がなく、すべてのレコードが同時に必要になることは少ない。つまり必要な程度に必要な分だけ整列されていればいい。例えば最大値だけ分かってればいいとか。順位キュー(*priority queue*)をつかう。

シュミレーションのシステム、ジョブのスケージュリング、数値計算などで使える。もっと高度なアルゴリズムを構築する部品としても順位キューが利用される。ファイル圧縮のアルゴリズムや、グラフの探索アルゴリズムの基礎をなす。これらの例はアルゴリズム設計の基本的道具として順位キューが果たす重要な役割のほんの一部。

順位キューの操作

| | |
|-:|:-|
| *construct* | *N*個の要素からなる順位キューを作る |
|*insert*|新しい要素を挿入する|
|*remove*|最大値をもつ要素を削除する|
|*replace*|最大値をもつ要素を新しい要素で置き換える。ただし新要素が大きくない場合に限る
|*change*|要素の優先順位を変更する|
|*delete*|任意の要素を指定してそれを削除する|
|*join*|２つの順位キューをまとめて１つの順位キューにする|

上記の6つの操作はヒープ(*heap*)というデータ構造で効率よく実現できる。

#### 素朴な実現法
---

順序のないリスト(*unordered list*)が使える。
![*construct*,*insert*,*remove*を簡単に実現できる](unordered_list.c)。

*construct*はただの配列のコピー。一定時間でできる。*remove*は配列の先頭から末尾まで操作するので*N*に比例する時間がかかる。

もう一つ、順序のついたリスト(*ordered list*)。

#### ヒープ
---

どのキーについても、その場所に王子て定まる２つの場所にあるいずれのキーよりも大きい。

完全２分木は配列で表現しやすい。

節点*j*の親は*j/2*で節点*k*の子は*2k*と*2k+1*にある。

####ヒープのアルゴリズム
---

![ヒープ](heap.c)。
*change*と*delete*は上記の手順を組み合わせてできる。

**性質11.1** 基本操作*insert*,*remove*,*replace*,*delete*,*change*(および*upheap*と*downheap*)はどれも、*N*要素のヒープに対して*2 lg N*回より少ない比較回数で実行できる。

#### ヒープソート(*Heapsort*)
---

エレガントで効率のよい整列法。余分な作業領域を使わず、どのような*N*個の要素の整列にも約*N log N*ステップしか実行しない。

![heapsort](heapsort.c)。

**性質11.2**　ボトムアップによるヒープの線形時間ですむ。

**性質11.3**　ヒープソートは、*N*個の要素の整列に*2N lg N*回以下の実行しかできない。

####間接的ヒープ
---

レコードを移動するのはめんどいから最大レコードのポインタだけあればいい。

![間接的ヒープ](*pqconstruct*)(pdconstrct)。

####もっと高度な実現法
---  
  
