## 基数整列法(*Radix sort*)
---

今までの2つのキーの比較と2つのレコードの交換を用いる整列法とは別の種類の整列法。キーがある制限をされているときに利用できる。

Cはビットの操作が楽。

#### ビット
---

キーが２進数で表現されているとして、基数整列法に必要な基本演算は、数の中から連続したビット列を抜き出すこと。0~1000までの範囲の整数をキーとする。この整数は10桁の2進数で表現できるとしてよい。機械語では*and*と*shift*でによって2進数からビット列を取り出すことができる。
*x*の右から*k*ビット目に現れている*j*ビットを値として返す手続きはこのようにかける

	usigned bits(unsigned x, int k, int j)
		{ return (x >> k) & ~(~0 << j); }
		
条件によっては線形時間で動く基数整列法のプログラムを書くことができる。
基数交換法(*radix exhange sort*)と直接基数法(*straight radix sort*)がある。


#### 基数交換法
---

![radix exchange](radix_exchange.c)。  

#### 直接基数法
---

![straight radix](straight_radix.c)。

#### 基数整列法の性能
---

**性質10.1**　基数交換法では平均で約*N lg N*ビットの比較を行う。

**性質10.2**　どちらの基数整列法も、*b*ビットのキー*N*個の整列に*Nb*回以下のビットしか調べない。

**性質10.3** 直接基数法は、*b*ビットのキーを持つレコード*N*個を整列するのに*b/m*回のパスでできる。ここで、*2<sup>m</sup>*個のカウンタのための作業領域が必要である。

#### 線形時間整列法
---

直接基数法によると、*b/m*回のパスでファイルを調べれば整列できる。*m*を大きくとれば非常に速い整列法がえられたことになる。

線形時間の整列法は当然多くの応用で利用できるが、思うほど万能ではない。
ランダムなビットのキーがランダムに並んでいるということに能率が左右される。きわめて大きいファイルではかなり速くなるかもしれないが、この場合には作業領域の大きさが負担になる。