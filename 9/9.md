## クイックソート(*Quicksort*)
---

いろいろな状況で能率よく働くので優れた汎用整列法で、計算資源を消費しない。

その場で整列できること、*N*個の要素の整列に平均約*N log N*回の操作しか必要でないこと。最悪の場合は*N<sup>2</sup>*に比例する回数の操作が必要であること。間違いのしやすい。

#### 基本アルゴリズム
---

クイックソートは分割統治法に基づく整列アルゴリズムである。
ファイルを２つの部分に分解してそれぞれ整列する。

![quicksort1.c](quicksort1.c)。

quicksort(a, 1, N)によってファイル全体を整列する。

この方法はpartition手続きである。

1. あるiに対して要素a[i]が最終位置にある。
2. a[l],…,a[i-1]のすべての要素はa[i]より小さいか等しい。
3. a[i+1],…,a[r]のすべての要素はa[i]より大きいか等しい。

この条件を満たすことは、次のような考え方で簡単に実現できる。
まず、最初にa[r]を選び、これが最終位置にくるばずの要素とする。次に配列の左端からはじめて、a[r]より大きい要素がみつかるまで右方へ順に走査していく。そして今度は、配列の右端からはじめて、a[r]より小さい要素が見つかるまで左方へ順に走査していく。この２つの走査が止まったところにある２つの要素はいずれも上の条件に反しているので、この要素を交換して、条件に合うようにする。(実はa[r]に等しい要素が見つかったときも走査を止めた方がよい)。これを続けることで、左からのポインタより左にはa[r]より小さい要素だけが並ぶ。

![quicksortのふたつめ](quicksort1.c)。

#### クイックソートの性能
---
クイックソートにとって最も都合がよいのは分割によりファイルが丁度半分分けられることが続く場合である。この場合、クイックソートで実効される比較回数は、次の分割統治の漸化式を満たす。

> C<sub>N</sub> = 2C<sub>N/2</sub> + N

ここで*2C<sub>N/2</sub>は二つの部分ファイルの整列コストであり、Nは各々の要素を調べるコストである。この漸化式は次の回を持つ

> C<sub>N</sub>　N lg N

実際にはここまでうまくいかないが、平均的に見て分割用の要素がほぼ真ん中らへんい落ち着く。

**性質9.1**　クイックソートは平均約*2N ln N*回の比較を行う。ランダムな順列に対するクイックソートの比較回数は次の漸化式で表せる。

>C<sub>N</sub> = N + 1 + 1/N Σ{1<=k<=N} 　(C<sub>k-1</sub> + C<sub>N-k</sub>)　N>=2の時

> C<sub>1</sub> = C<sub>0</sub> =  0

ここで*N+1*の項は、分割用の要素がそれ以外の要素と比較される回数である。

#### 再帰呼び出しの除去
---

スタックを用いてクイックソートから再帰呼び出しを除去することができる。
ここで、スタックには、これから整列する必要のある部分ファイルを入れ、部分ファイルを処理する際にスタックから取り出す。つまり分割によって２つの部分ファイルが作られるのでそれをスタックにプッシュする。

![not rec](not_rec_quicksort.c)。

#### 小さい部分ファイル
---

2つ目の改良点は多くの小さい部分ファイルに対して再帰的に自分自身を呼び出すことに注目して、小さい部分ファイルが現れると、なるげくそれ専用の方法を使うようにすること。たとえば*M*を定数として

	if(r-l <= M) insertion(a, l, r);
	
とする、*M*はだいたい5から25くらいの範囲内ならだいたい同じになる。この改良で全実行時間は20%ぐらい減る。

分割がすべて終了した時には、ファイル全体がほとんど整列している。つまり挿入整列法が最適となる。

またこの方法を使うとクイックソートにある種のバグがあったとしても、ファイルが正しく整列されてしますことがある。つまりコストがかかりすぎるということでしたバグがあることが分からない。

#### 3要素の中央値
---

配列の中から３つの要素を選んでpartitionする。25%から30%の削減ができる。

これ以上速くしたいなら機械語かアセンブリでコーディングするのがよい。

#### 選択
---

整列に関する問題として、数の集合の中の中央値を求めるものがあり、必ずしも完全な整列を必要としない。この問題は、統計の計算やデータ処理によく現れる。これにはクイックソートの分割を利用する。
中央値を見つける問題は、数の集合の中で*k*番目に小さい要素を求める選択(*selection*)といわれる問題の特別なものである。選択問題では*k*番目の要素より、*k-1*個の要素が小さく、*N-k*子の要素が大きいということを決定しない限り、*k*番目の要素を見つけられないので、互いの選択アルゴリズムはたいして余分な計算を必要としない。

大きいファイルの一部だけ残しておくとか。ファイルの上位10%を選択すること。

*k*が小さいとき、選択整列法は非常に速く、*Nk*に比例する時間で実行される。

どんな*k*に対しても平均して線形時間で走る面白い方法は![クイックソートの分割手続きを応用するもの](select.c)である。ファイルの*k*番目に小さい要素がほしいとすると*k==i*なら問題が解けたことになる。それ以外の場合は、分割した片方だけ調べていけばよい。

この手続きは配列を並び替えて、a[1],…,a[k-1]がa[k]より小さいか等しく…なるようにする。

![もうひとつ](select2.c)。

**性質9.2**　クイックソートに基づく選択法は、平均的に線形時間で走る。


