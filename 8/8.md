## 初等的な整列法
---

ごく小さな項目の整列には初等的なsortの方がすぐれていることもある。ここで取り上げるのは、約*N<sup>2</sup>*ステップかかる。*N*が十分小さければ、問題はない。

#### ゲームのルール
---

整列法は内部整列(*internal sorting*)と外部整列(*external sorting*)に分かれる。

性能をはかるパラメータは実行時間と記憶域の使用量である。*N<sup>2</sup>*の方法と*N log N*の方法がある。比較を用いたものであれば、最低でも*N log N*回の比較が必要となる。記憶域は３つの場合がある。第1に、その場で整列するもので、少しのスタックと表を必要とする。第2に、リンクによるリストを利用するもので、リストのポインタのために*N*個の余分な語が必要になる。第３に、配列のコピーを作るために十分大きい作業領域が必要になる。

安定性(*stability*)が重要になることもある。

![sort3.c](sort3.c)。

最初の３つの要素だけを整列します。

#### 選択整列
---

![選択整列法](selection_sort.c)(*selection sort*)です。一番小さいの選んで要素交換してっていくやつ。自分はよく使う。

#### 挿入整列
---

![挿入整列法](insertion_sort.c)(*insertion sort*)です。要素をひとつずつ取り上げ、既に整列した配列に挿入する。

このコードはこのままでは正しく動かない。vが配列の最小要素の時、whileで配列の左端に出てしまう。これを直すにはa[0]に番兵のキーを置き、この値を配列の中の最小要素より大きくならないようにすればよい。

*while*のループから抜け出すには*break*または*goto*を使うことができる。優秀でないプログラマは*goto*を避ける傾向にある。

#### バブル整列法
---

入門的な講義でよく取り上げられる![バブル整列法](bubble_sort.c)(*bubble sort*)。ファイル全体を見るパスを繰り返しながら、隣り合う要素の大小順が狂っていれば交換する。各要素が正しい位置に移動するまでに、多くの仕事が必要。

#### 初等的な整列法の性能
---

**性質8.1**  選択整列法は、約*N<sup>2</sup>/2*回の比較と約*N*回の交換を行う。最悪の場合には*O(N<sup>2</sup>)*になるが、平均の場合に*O(N log N)*となる。

**性質8.2**  挿入整列法は、平均の場合に約*N<sup>2</sup>/4*回の比較と約*N<sup>2</sup>/8回の交換を行う。最悪の場合にはそれぞれ２倍になる。

**性質8.3**   バブル整列法は、最悪の場合も平均の場合も、約*N<sup>2</sup>/2*回の比較と約*N<sup>2</sup>/2*回の交換を行う。

**性質8.4**  挿入整列法は、ほとんど整列しているファイルに対して線形時間で走る

**性質8.5**  選択整列法は、大きいレコードと小さいレコードからなるファイルに対して、線形時間で走る。

#### 大きいレコードの整列法
---

どんな整列法でも調節すれば、レコード全体の交換回数を*N*回にすることが可能である。![insitu.c](insitu.c)、

![ポインタを使った挿入整列法](insertion_sort_of_pointer.c)。

#### シェルソート(*Shellsort*)
---

挿入整列法の簡単な拡張。互いに*h*要素分だけ離れた要素の集まりからなる部分ファイルを整列していく。

![shellsort.c](shellsort.c)。

計算量は*N(log N)<sup>2</sup>*か*N<sup>1.25</sup>*であると予測される。

**性質8.6** シェルソートでは、*N*の*3/2*乗回より多く比較されることがない。ここで、1,4,13,40,121,…の増分列を用いるものとする。

クイックソートでも非常に大きい*N*場合を除いてシェルソートよりもだいたい2倍くらいしか速くないし、複雑。実用上はシェルソートでも十分なことも多い。

#### 分配計数法(*distribution counting*)
---

ある種の非常に特殊な状況では、単純な整列法が使える。それは、"1から*N*までの互いに異なる整数をキーとするレコード*N*個からなるファイル"を整列する場合である。

